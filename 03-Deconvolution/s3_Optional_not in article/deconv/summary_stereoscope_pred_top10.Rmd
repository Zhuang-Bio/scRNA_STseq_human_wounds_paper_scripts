---
title: "Summary stereoscope predictions"
author: "Åsa Björklund"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    self_contained: true
    highlight: tango
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    fig_caption: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, result='hold',fig.width=12,tidy=TRUE)
knitr::opts_knit$set(progress=TRUE,verbose=TRUE)
```

Stereoscope was run for all sections using the scRNAseq data and gene list with top10 genes at each branch of the cluster tree.

## Load

### Load packages

```{r packages}
suppressPackageStartupMessages(require(Matrix))
suppressPackageStartupMessages(require(dplyr))
suppressPackageStartupMessages(require(Seurat))
suppressPackageStartupMessages(require(ggplot2))
suppressPackageStartupMessages(require(gridExtra))
source("../functions/overlap_phyper_v2.R")
```

```{r}
cl.colors = c("#e6194B", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", "#42d4f4",
    "#f032e6", "#bfef45", "#fabed4", "#469990", "#dcbeff", "#9A6324", "#fffac8",
    "#800000", "#aaffc3", "#808000", "#ffd8b1", "#000075", "#a9a9a9", "#000000")
names(cl.colors) = as.character(0:20)


```


Load ST data

```{r, }
st.data = readRDS(file = "../../spatial/results/all/all_harmony.rds")

p1 = DimPlot(st.data, label = T, cols = cl.colors) + NoAxes() + ggtitle("Integrated clusters")
p3 = DimPlot(st.data, group.by = "Sample_name") + NoAxes()
grid.arrange(p1,p3, ncol=2)
```

```{r,fig.height=10}
p2 = SpatialDimPlot(st.data, stroke = 0,  cols = cl.colors,  combine = F)
grid.arrange(grobs = p2, ncol=4)

```

Load deconvolution results.

```{r}
input_dir = "../../deconv/results/stereoscope10/"
samples = sort(unique(st.data$Sample_name))

# obs! Cell names does not have the sample extension in the barcode name.
s = colnames(st.data)[match(samples, st.data$Sample_name)]
extensions = unlist(lapply(strsplit(s, "_"), function(x) x[2]))
names(extensions) = samples

alldata = list()
for (sample in samples){
  dfile = file.path(input_dir,sample,"proportions.csv")
  if (!file.exists(dfile)){
    print(paste0("no file: ",dfile, ", adding random matrix..."))
    tmp = matrix(runif(1),  sum(st.data$Sample_name ==sample), ncol(alldata[[1]]))
    rownames(tmp) = colnames(st.data)[st.data$Sample_name == sample]
    colnames(tmp) = colnames(alldata[[1]])
    alldata[[sample]] = tmp
    next
  }
  tmp = read.csv(dfile, row.names = 1)
  rownames(tmp) = paste(rownames(tmp), extensions[sample], sep="_")
  alldata[[sample]] = tmp
  print(range(rowSums(tmp)))
}



all = Reduce(rbind, alldata)
all = t(all)
all = all[,colnames(st.data)]

# OBS! Forgot to change the annotation and have instead deconvolved with cluster numbers
annot = readxl::read_xlsx("../../scRNAseq/results/zhuang_analysis/oct12/cell types for each cluster - Zhuang Liu.xlsx",
    sheet = 1)

celltypes = annot$CellType
celltypes = setdiff(celltypes, "Basal-IV")
celltypes = sort(celltypes)


rownames(all) =  celltypes

# add as an assay object.
st.data[['Stereoscope']] <- CreateAssayObject(counts = all)
```

# Plot results

Plotting functions

```{r}
plot.gene.umap = function(sdata, genes, reduction = "umap", assay = "Spatial", ncol=5,nrow=6, nPlot=NULL){
  cc = scale_color_gradientn(colors = c("grey","yellow","red","black"))
  small.leg <- theme(legend.text = element_text(size=6), legend.key.width = unit(0.1,"cm"))
  sdata@active.assay = assay
  pl = list()
  for (i in 1:length(genes)){
    pl[[i]] = FeaturePlot(sdata,features = genes[i], slot = "data",  pt.size = 0.01, order = T, reduction = reduction) + NoAxes() + cc + small.leg + ggtitle(genes[i]) + theme(plot.title = element_text(size=10))
  }
  if (is.null(nPlot)){ nPlot = length(genes)}
  if (nPlot > ncol*nrow){
    print("Cannot fit all figures into a single plot")
    nPlot = ncol*nrow
  }
  nBin = ceiling(length(pl)/nPlot)
  for (i in 1:nBin){
    x = (i*nPlot+1-nPlot):min(length(pl),i*nPlot)
    grid.arrange(grobs=pl[x], ncol=ncol, nrow=nrow)
  }
}

```




```{r}
plot.gene.st = function(sdata,genes,images,assay="Spatial", ncol=5,nrow=6, nPlot=NULL){
  
  tmp = data.frame(t(sdata@assays[[assay]]@counts[genes,]))
  tmp$x = sdata@images[[sample]]@coordinates$imagecol
  tmp$y = -sdata@images[[sample]]@coordinates$imagerow
  
  cc = scale_color_gradientn(colors = c("gray","yellow","red","black"))
  small.leg <- theme(legend.text = element_text(size=6), legend.key.width = unit(0.1,"cm"))
  pl = list()
  for (g in genes){
    g2 = sym(g)
    pl[[g]] = ggplot(tmp, aes(x=x,y=y,color= !! g2)) + geom_point()  + theme_classic() + cc + ggtitle(g) + NoAxes() + small.leg
  }
  if (is.null(nPlot)){ nPlot = length(genes)}
  if (nPlot > ncol*nrow){
    print("Cannot fit all figures into a single plot")
    nPlot = ncol*nrow()
  }
  nBin = ceiling(length(pl)/nPlot)
  for (i in 1:nBin){
    x = (i*nPlot+1-nPlot):min(length(pl),i*nPlot)
    grid.arrange(grobs=pl[x], ncol=ncol, nrow=nrow)
  }
}

```





```{r, fig.height=10}
plot.gene.umap(st.data, celltypes, assay = "Stereoscope")
```


```{r, fig.width=12, fig.height=10}
st.data@active.assay = "Stereoscope"
for (g in celltypes){
  p = SpatialFeaturePlot(st.data, features = g, images = samples, alpha = c(0.2,1), combine = F)
  grid.arrange(grobs=p, ncol = 4, top = g)
}

```


### Broad celltypes

Add up total count by main 4 celltypes:

* FB
* Keratinocytes
* Immune
* Other

```{r}
ct.groups = list()
ct.groups$fib = celltypes[grepl("^FB",celltypes)]
ct.groups$kera = celltypes[c(2:4,10:11,22:24)]
ct.groups$immune = celltypes[c(1,5,12,14,15,17,18,19,25)]
ct.groups$rest = setdiff(celltypes, unlist(ct.groups))


for (gr in names(ct.groups)){
  s = colSums(st.data@assays$Stereoscope@counts[ct.groups[[gr]],])
  name = sprintf("Total_%s",gr)
  st.data = AddMetaData(st.data, s, col.name = name)
}
```

```{r, fig.height=5}
total.names = paste0("Total_", names(ct.groups))

p = SpatialFeaturePlot(st.data, total.names, combine = F)

for (i in 1:16){
  pl = p[i+c(0,16,32,48)]
  grid.arrange(grobs = pl, ncol = 4)
}

```



# Celltype proportions

## Per section


```{r}
cell.prop = list()
for (s in samples){
    cell.propDW = rowSums(st.data@assays$Stereoscope@counts[,st.data$Sample_name == s])
    cell.propDW = cell.propDW/sum(cell.propDW)
    cell.prop[[s]] = cell.propDW
}

cell.prop = Reduce(cbind, cell.prop)
colnames(cell.prop) = samples

```


```{r}
tot.prop = data.frame(cell.prop)
# reoder to have all Skin next to eachother etc.
s = unlist(lapply(strsplit(samples, "_"), function(x) x[2]))
o = order(s)
tot.prop = tot.prop[,o]

tot.prop$celltype = rownames(tot.prop)

l = reshape2::melt(tot.prop, id.vars = "celltype")

p5 = ggplot(l, aes(x = variable, y = value, fill = celltype)) + geom_bar(position = "fill",
    stat = "identity") + RotatedAxis()
```

```{r,fig.height=10}
# define colors for the clusters.

cols = rep(NA, 26)
# greens for basal
cols[2:4] = colorRampPalette(c("green", "darkgreen"))(3)
# pink/purple for fibs
cols[6:9] = colorRampPalette(c("pink", "purple3"))(4)
# blu spinous
cols[22:24] = colorRampPalette(c("lightblue", "darkblue"))(3)
# cyans for Granular
cols[10:11] = c("cyan", "cyan3")
# immune cells in yellow to orange
cols[c(1, 5, 14, 15, 17:19, 25)] = colorRampPalette(c("yellow", "red"))(8)
# rest in grays
cols[c(12, 13, 16, 20, 21, 26)] = colorRampPalette(c("grey82", "gray30"))(6)

names(cols) = celltypes

p5 + scale_fill_manual(values = cols)
```


Also plot as violins

```{r, fig.height=10}
# Plot 9 at a time

p = VlnPlot(st.data, features = celltypes,  group.by = "Sample_name", pt.size = 0, combine = F)
p = lapply(p, function(x) x + theme(axis.text.x = element_text(size = 6)) + NoLegend())


grid.arrange(grobs = p[1:9], ncol=3)
grid.arrange(grobs = p[10:18], ncol=3)
grid.arrange(grobs = p[19:26], ncol=3)
```


## Per cluster

Per cluster from integrated analysis

```{r}
cell.prop.cl = list()
for (cl in unique(st.data$seurat_clusters)){
    cell.propDW = rowSums(st.data@assays$Stereoscope@counts[,st.data$seurat_clusters == cl])
    cell.propDW = cell.propDW/sum(cell.propDW)
    cell.prop.cl[[cl]] = cell.propDW
}

cell.prop.cl = Reduce(cbind, cell.prop.cl)
colnames(cell.prop.cl) = unique(st.data$seurat_clusters)

cell.prop.cl = cell.prop.cl[,order(as.numeric(colnames(cell.prop.cl)))]
```

```{r, fig.height=10}
tot.prop = data.frame(cell.prop.cl)

tot.prop$celltype = rownames(tot.prop)

l = reshape2::melt(tot.prop, id.vars = "celltype")

p5 = ggplot(l, aes(x = variable, y = value, fill = celltype)) + geom_bar(position = "fill",
    stat = "identity") + RotatedAxis()
p5 + scale_fill_manual(values = cols)
```

And as violins

```{r, fig.height=10}
VlnPlot(st.data, features = celltypes[1:9],  pt.size = 0)
VlnPlot(st.data, features = celltypes[10:18],   pt.size = 0)
VlnPlot(st.data, features = celltypes[19:26],  pt.size = 0)

```


# Cluster based on celltype composition

```{r}
st.data$integrated_clust = st.data$seurat_clusters

nPC = 25
umap_name = "umap_celltypes"
pca_name = "pca_celltypes"
clust_name = "celltype_clust"
st.data = ScaleData(st.data)
st.data = RunPCA(st.data, features = celltypes, reduction.name = pca_name, verbose = F,  assay = "Stereoscope")
ElbowPlot(st.data)
st.data = RunUMAP(st.data, reduction = pca_name, reduction.name = umap_name, dims = 1:nPC,
    verbose = F, assay = "Stereoscope")
st.data = FindNeighbors(st.data, reduction = pca_name, dims = 1:nPC, verbose = F)
st.data = FindClusters(st.data, resolution = 0.4, verbose = F)

p = DimPlot(st.data, reduction = umap_name, group.by = "integrated_clust") + NoAxes()
p2 = DimPlot(st.data, label = T, reduction = umap_name) + NoAxes() + ggtitle("celltype clust")
p3 = DimPlot(st.data, group.by = "Sample_name", reduction = umap_name) + NoAxes()
p4 = DimPlot(st.data, group.by = "Condition", reduction = umap_name) + NoAxes()
grid.arrange(p,p2,p3, p4, ncol = 2)


```

Sample distribution per cluster 

```{r}
ggplot(st.data@meta.data, aes(x = seurat_clusters, fill = Condition, alpha = Donor)) +
    geom_bar(position = "fill") + theme_classic()

#ggplot(st.data@meta.data, aes(x=seurat_clusters, fill=Sample_name)) + geom_bar(position = "fill")
```


Celltype distribution per cluster

```{r}
cell.prop.cl2 = list()
for (cl in unique(st.data$seurat_clusters)) {
    cell.propDW = rowSums(st.data@assays$Stereoscope@counts[, st.data$seurat_clusters ==
        cl])
    cell.propDW = cell.propDW/sum(cell.propDW)
    cell.prop.cl2[[cl]] = cell.propDW
}

cell.prop.cl2 = Reduce(cbind, cell.prop.cl2)
colnames(cell.prop.cl2) = unique(st.data$seurat_clusters)

cell.prop.cl2 = cell.prop.cl2[, order(as.numeric(colnames(cell.prop.cl2)))]
```

```{r}
tot.prop = data.frame(cell.prop.cl2)

tot.prop$celltype = rownames(tot.prop)

l = reshape2::melt(tot.prop, id.vars = "celltype")

p5 = ggplot(l, aes(x = variable, y = value, fill = celltype)) + geom_bar(position = "fill",
    stat = "identity") + RotatedAxis()
p5 + scale_fill_manual(values = cols)
```


```{r, fig.height=10}
p3 = SpatialDimPlot(st.data, images = samples, combine = F)
grid.arrange(grobs = p3, ncol=4)
```


```{r}
VlnPlot(st.data, features = celltypes[1:9],  pt.size = 0)
VlnPlot(st.data, features = celltypes[10:18],   pt.size = 0)
VlnPlot(st.data, features = celltypes[19:26],  pt.size = 0)

```

Plot onto integrated umap based on RNA assay

```{r}
DimPlot(st.data, reduction = "umap", label = T) + NoAxes()
```

Very little agreement with the expression clustering, except for in the clear outlier clusters.

```{r}
p3 = VlnPlot(st.data, features = "nFeature_Spatial", pt.size = 0) +
    NoLegend()
p4 = VlnPlot(st.data, features = "percent_mito", pt.size = 0 ) +
    NoLegend()
grid.arrange(p3, p4, ncol = 2)
```


## With celltype stats

Abundance of top celltype

```{r}
prop = t(all)
top = apply(prop, 1, max)

hist(top,100, main = "Abundance of top celltype")

```

```{r}
st.data$top.abundance = top

VlnPlot(st.data, features = "top.abundance", group.by = "Sample_name", pt.size = 0)
```



Number of celltypes with more than 5% abundance.


```{r}
cutoff = 0.05

nCelltypes = rowSums(prop>cutoff)

hist(nCelltypes,100, main = "Celltypes per spot")
```


```{r}
st.data$nCelltypes = nCelltypes

VlnPlot(st.data, features = "nCelltypes", group.by = "Sample_name", pt.size = 0)
```

# Celltype abundance across timepoints

```{r}
total = colSums(prop)
total = total/sum(total)

barplot(total, las=2, main = "Abundance all sections")
```

Per timepoint

```{r}
# calculate for each section.
tmp = data.frame(prop)

tmp$Sample = st.data$Sample_name


library(dplyr)
prop.sample = tmp %>%   group_by(Sample) %>%  summarise(across(everything(), sum))

prop.sample = data.frame(prop.sample)
rownames(prop.sample) = prop.sample$Sample
prop.sample = prop.sample[,-1]
prop.sample = sweep(prop.sample,1,rowSums(prop.sample),"/") 


s = strsplit(rownames(prop.sample), "_")
prop.sample$Condition = unlist(lapply(s, function(x) x[2]))

library(reshape2)
m = melt(prop.sample, id.vars = "Condition")
```

```{r, fig.height=12}
ggplot(m, aes(x=Condition, y=value)) + geom_boxplot(outlier.shape = NA) + geom_jitter() + facet_wrap(~variable, scales = "free") + RotatedAxis()

```


# Celltype co-occurence

Count only when a celltype occurs at least with 5% abundance.

Across all sections:

```{r}
cutoff = 0.05

co.occ =  sapply(celltypes, function(x) which(prop[,x ] > cutoff))

o = overlap_phyper2(co.occ, co.occ, title = "All", remove.diag = T)
```

Same but one condition at a time

```{r}
all.overlap = list()
for (cond in unique(st.data$Condition)){
  co.occ =  sapply(celltypes, function(x) which(prop[st.data$Condition == cond ,x ] > cutoff))
  all.overlap[[cond]] = overlap_phyper2(co.occ, co.occ, title = cond, remove.diag = T)
}

```


## As graphs

Draw edges for any celltpes that overlaps with pvalue < 0.1

Edge weight is thicker if pvalue is lower. 

```{r, fig.height=10}
library(igraph)
make.igraph = function(ptest, cutoff = 0.1, title = "Celltype co-occurence"){
  pvals = ptest$P[-ncol(ptest$P),-nrow(ptest$P)]

  pseudo = min(pvals[pvals>0 & !is.na(pvals)])
  pvals[pvals==0]=pseudo
  
  # filer all edgens with pval > cutoff
  pvals[pvals>cutoff]=1
  
  # convert to weights
  w = -log10(pvals)
  g = graph_from_adjacency_matrix(w, mode = "undirected", weighted = T, diag = F)
  set.seed(13)
  g.layout<-layout_with_graphopt(g)
  #g.layout<-layout_with_lgl(g, maxiter = 500)
  V(g)$color = cols
  
  # scale point size by proportions
  nC = ptest$M[-ncol(ptest$M),ncol(ptest$M)]
  
  #plot.igraph(g,layout=g.layout, vertex.label.color="black", edge.width=E(g)$weight/10, main = title)
  plot.igraph(g,layout=g.layout, vertex.label.color="black", edge.width=E(g)$weight/10, 
              vertex.size=nC/sum(nC)*200, vertex.label.dist = 2, main = title)
  
  return(list(g=g,layout=g.layout))
}

g = make.igraph(o, title = "All")
```


Make one per condition

```{r, fig.height=10}
par(mfrow=c(2,2), mar=c(0,0,1,0))
graphs = sapply(names(all.overlap), function(x) make.igraph(all.overlap[[x]], title = x))
```


## With weighting based on gene detection

Estimate number of cells per spot based on gene detection, make a conditional cutoff to call a cell present based on number of cells.

Most of the dermis part only has nuclei at very sparse positions, so lowest number would be a single cell.

First, look at the number of celltype predicted (with cutoff > 5% ) vs reads.

```{r}
smoothScatter(nCelltypes,st.data$nCount_Spatial)

```

Clearly the ones with many different predicted celltypes are from spots with few detected genes. As many different celltype end up above the cutoff.

Proportion of largest celltype vs counts:

```{r}
smoothScatter(top,st.data$nCount_Spatial)

```



```{r}
FeatureScatter(st.data, feature1 = "nFeature_Spatial", feature2 = "nCount_Spatial")
h = hist(st.data$nFeature_Spatial,100)
h = hist(st.data$nCount_Spatial,100)

```

Assume that lowest count is 1 cell, highest is 50 cells

```{r}
nCount = st.data$nCount_Spatial 

nCell = (nCount-min(nCount))/max(nCount)*50 + 1

nCell = round(nCell)

hist(nCell, 50)

```

Define cutoff for presense of a cell as 1/nCell, e.g. if two cells, the prediction should be 50%, if 50 cells, prediction of 2% is allowed.

But allow some lenience, so that we can have slightly below the cutoff (90% of cutoff).

Many spots have signal from multiple celltypes at similar level, Also spots with most likely one spot may have highest proportion at e.g. 0.15. In that case take top celltype.

```{r}
cutC = 1/(nCell+1)

detC = list()
for(i in 1:nrow(prop)){
  pr = colnames(prop)[prop[i,]>cutC[i]]
  if (length(pr) ==0){ }
  
  detC[[i]]=pr
}

nC = unlist(lapply(detC,length))



```




```{r}
saveRDS(st.data, file = file.path(input_dir, "seurat_object.rds"))
```



```{r, eval=FALSE}
# adding legend with point sizes.


require(igraph)
er_graph <- erdos.renyi.game(100, 5/100)
value<-runif(100)
sizeCut<- c(0.2,0.4,0.6,0.8,1.0)
sizeCutScale <- sizeCut*10
vertex.size<-value*10
plot(er_graph, vertex.label=NA, vertex.size=vertex.size)
legend('topleft',legend=unique(sizeCut),pt.cex= sizeCutScale,col='black')
a <- legend('topleft',legend=unique(sizeCut),pt.cex=sizeCutScale/200,col='white',
            pch=21, pt.bg='white')
x <- (a$text$x + a$rect$left) / 2
y <- a$text$y
symbols(x,y,circles=sizeCutScale/200,inches=FALSE,add=TRUE,bg='orange')
```


### Session info

```{r}
sessionInfo()
```
