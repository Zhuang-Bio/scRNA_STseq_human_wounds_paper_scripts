---
title: "Compare deconv methods"
author: "Åsa Björklund"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    self_contained: true
    highlight: tango
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    fig_caption: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, result='hold',fig.width=12,tidy=TRUE)
knitr::opts_knit$set(progress=TRUE,verbose=TRUE)
```

Deconvolution was tested on four sections, one per timepoint.

Methods tested:

* SpatialDWLS was tested with the fc0.5_pval0.01 gene list.
* RCTD was run with default parameters, finds its own gene list.
* Stereoscope with same gene list as DWLS

## Load

### Load packages

```{r packages}
suppressPackageStartupMessages(require(Matrix))
suppressPackageStartupMessages(require(dplyr))
suppressPackageStartupMessages(require(Seurat))
suppressPackageStartupMessages(require(ggplot2))
suppressPackageStartupMessages(require(gridExtra))
source("../functions/overlap_phyper_v2.R")
```

```{r}
cl.colors = c("#e6194B", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", "#42d4f4",
    "#f032e6", "#bfef45", "#fabed4", "#469990", "#dcbeff", "#9A6324", "#fffac8",
    "#800000", "#aaffc3", "#808000", "#ffd8b1", "#000075", "#a9a9a9", "#000000")
names(cl.colors) = as.character(0:20)


```


```{r, }
input_dir = "../../deconv/results/"
samples = c("Donor4_Skin", "Donor1_Wound1", "Donor1_Wound7", "Donor2_Wound30")

st.data = readRDS(file = "../../spatial/results/all/all_harmony.rds")
st.data = st.data[,st.data$Sample_name %in% samples]

#cl.colors = cl.colors[unique(st.data$seurat_clusters)]

p1 = DimPlot(st.data, label = T, cols = cl.colors) + NoAxes() + ggtitle("Integrated clusters")
p3 = DimPlot(st.data, group.by = "Sample_name") + NoAxes()
grid.arrange(p1,p3, ncol=2)
```

```{r,fig.height=10}
p2 = SpatialDimPlot(st.data, stroke = 0,  cols = cl.colors, images = samples, combine = F)
grid.arrange(grobs = p2, ncol=2)

```

Plotting functions

```{r}
plot.gene.umap = function(sdata, genes, reduction = "umap", assay = "Spatial", ncol=5,nrow=6, nPlot=NULL){
  cc = scale_color_gradientn(colors = c("grey","yellow","red","black"))
  small.leg <- theme(legend.text = element_text(size=6), legend.key.width = unit(0.1,"cm"))
  sdata@active.assay = assay
  pl = list()
  for (i in 1:length(genes)){
    pl[[i]] = FeaturePlot(sdata,features = genes[i], slot = "data",  pt.size = 0.01, order = T, reduction = reduction) + NoAxes() + cc + small.leg + ggtitle(genes[i]) + theme(plot.title = element_text(size=10))
  }
  if (is.null(nPlot)){ nPlot = length(genes)}
  if (nPlot > ncol*nrow){
    print("Cannot fit all figures into a single plot")
    nPlot = ncol*nrow
  }
  nBin = ceiling(length(pl)/nPlot)
  for (i in 1:nBin){
    x = (i*nPlot+1-nPlot):min(length(pl),i*nPlot)
    grid.arrange(grobs=pl[x], ncol=ncol, nrow=nrow)
  }
}

```




```{r}
plot.gene.st = function(sdata,genes,images,assay="Spatial", ncol=5,nrow=6, nPlot=NULL){
  
  tmp = data.frame(t(sdata@assays[[assay]]@counts[genes,]))
  tmp$x = sdata@images[[sample]]@coordinates$imagecol
  tmp$y = -sdata@images[[sample]]@coordinates$imagerow
  
  cc = scale_color_gradientn(colors = c("gray","yellow","red","black"))
  small.leg <- theme(legend.text = element_text(size=6), legend.key.width = unit(0.1,"cm"))
  pl = list()
  for (g in genes){
    g2 = sym(g)
    pl[[g]] = ggplot(tmp, aes(x=x,y=y,color= !! g2)) + geom_point()  + theme_classic() + cc + ggtitle(g) + NoAxes() + small.leg
  }
  if (is.null(nPlot)){ nPlot = length(genes)}
  if (nPlot > ncol*nrow){
    print("Cannot fit all figures into a single plot")
    nPlot = ncol*nrow()
  }
  nBin = ceiling(length(pl)/nPlot)
  for (i in 1:nBin){
    x = (i*nPlot+1-nPlot):min(length(pl),i*nPlot)
    grid.arrange(grobs=pl[x], ncol=ncol, nrow=nrow)
  }
}

```

```{r}
plot.prop = function(sdata, assay="DWLS"){
  cell.prop = list()
  for (s in unique(sdata$Sample_name)){
    cell.propDW = rowSums(sdata@assays[[assay]]@counts[,sdata$Sample_name == s])
    cell.propDW = cell.propDW/sum(cell.propDW)
    cell.prop[[s]] = cell.propDW
  }
  par(mar=c(8,3,2,1), mfrow = c(2,2))
  for (s in names(cell.prop)){
    barplot(sort(cell.prop[[s]], decreasing = T), las=2, main = sprintf("%s - %s",s,assay))
  }
  return(cell.prop)
}
```

# RCTD

```{r}
alldata = list()
alldata$RCTD = list()

for (sample in samples){
  dfile = file.path(input_dir,"rctd",sample,"RCTD_res.csv")
  alldata$RCTD[[sample]] = read.csv(dfile, row.names = 1)
  print(range(rowSums(alldata$RCTD[[sample]])))
}


all = Reduce(rbind, alldata$RCTD)
# normalize per spot?
# D = sweep(D, 1, rowSums(D), '/') 

# add as an assay object.
st.data[['RCTD']] <- CreateAssayObject(counts = as.matrix(t(all)))

celltypes = colnames(all)

```

Plot spatial image in background and alpha by celltype score.

```{r, fig.width=12, fig.height=4}
st.data@active.assay = "RCTD"
for (g in celltypes){
  p = SpatialFeaturePlot(st.data, features = g, images = samples, alpha = c(0.2,1), combine = F)
  grid.arrange(grobs=p, ncol = 4, top = g)
}

```

```{r, eval=FALSE}
g = "Granular.I"
p = SpatialFeaturePlot(st.data, features = g, images = samples, alpha = c(0.2,1), combine = F)
tmp = g[[2]]

tmp + scale_color_gradientn(colors = c("gray","yellow","red","black"))
tmp + scale_color_gradientn(colors = c("gray","yellow","red","black"), name = g)
tmp + scale_color_gradientn(colors = c("gray","yellow","red","black"), name = tmp$plot_env$col.by )
```



Check what are the most abundant celltypes

```{r}
cell.prop = list()
cell.prop$RCTD = plot.prop(st.data, assay = "RCTD")
```

# Stereoscope

```{r}
alldata$Stereoscope = list()

# obs! Cell names does not have the sample extension in the barcode name.
s = colnames(st.data)[match(samples, st.data$Sample_name)]
extensions = unlist(lapply(strsplit(s, "_"), function(x) x[2]))
names(extensions) = samples

for (sample in samples){
  dfile = file.path(input_dir,"stereoscope",sample,"proportions.csv")
  if (!file.exists(dfile)){ 
    print(sprintf("No file %s", dfile)); 
    next 
  }
  tmp = read.csv(dfile, row.names = 1)
  rownames(tmp) = paste(rownames(tmp), extensions[sample], sep="_")
  
  alldata$Stereoscope[[sample]] = tmp
  print(range(rowSums(tmp)))
}


all = Reduce(rbind, alldata$Stereoscope)
# normalize per spot?
# D = sweep(D, 1, rowSums(D), '/') 

# add as an assay object.
st.data[['Stereoscope']] <- CreateAssayObject(counts = as.matrix(t(all)))
```

Plot spatial image in background and alpha by celltype score.

```{r, fig.width=12, fig.height=4}
st.data@active.assay = "Stereoscope"
for (g in celltypes){
  p = SpatialFeaturePlot(st.data, features = g, images = samples, alpha = c(0.2,1), combine = F)
  grid.arrange(grobs=p, ncol = 4, top = g)
}

```

Check what are the most abundant celltypes

```{r}
cell.prop$Stereoscope = plot.prop(st.data, assay = "Stereoscope")
```


# DWLS

```{r}
alldata$DWLS = list()

for (sample in samples){
  dfile = file.path(input_dir,"dwls",sample,"dwls_proportions.csv")
  if (!file.exists(dfile)){ 
    print(sprintf("No file %s", dfile)); 
    spots = colnames(st.data)[st.data$Sample_name == sample]
    tmp = mat.or.vec(length(spots), length(celltypes))
    tmp[]=0.1
    rownames(tmp)=spots
    colnames(tmp)=celltypes
    alldata$DWLS[[sample]] = tmp
    next 
  }
  tmp = read.csv(dfile, row.names = 1)
  rownames(tmp) = tmp[,1]
  tmp = tmp[,-1]
  rownames(tmp) = paste(rownames(tmp), extensions[sample], sep="_")
  
  alldata$DWLS[[sample]] = tmp
  print(range(rowSums(tmp)))
}


all = Reduce(rbind, alldata$DWLS)
# normalize per spot?
# D = sweep(D, 1, rowSums(D), '/') 

# add as an assay object.
st.data[['DWLS']] <- CreateAssayObject(counts = as.matrix(t(all)))
```

Plot spatial image in background and alpha by celltype score.

```{r, fig.width=12, fig.height=4}
st.data@active.assay = "DWLS"
for (g in celltypes){
  p = SpatialFeaturePlot(st.data, features = g, images = samples, alpha = c(0.2,1), combine = F)
  grid.arrange(grobs=p, ncol = 4, top = g)
}

```

Check what are the most abundant celltypes

```{r}
cell.prop$DWLS = plot.prop(st.data, assay = "DWLS")
```

# Compare 

## Proportion

Check average proportion of each celltype per spot.

```{r}
tot.prop = lapply(cell.prop, function(x) { tmp = data.frame(Reduce(cbind, x)); colnames(tmp)=names(x); return(tmp)})
tot.prop = Reduce(cbind,tot.prop)
colnames(tot.prop) = paste(colnames(tot.prop), rep(names(cell.prop), each= 4), sep = "_")

# reorder by sample 
tot.prop = tot.prop[,order(colnames(tot.prop))]

tot.prop$celltype = celltypes

l = reshape2::melt(tot.prop, id.vars = "celltype")

p5 = ggplot(l, aes(x = variable, y = value, fill = celltype)) + geom_bar(position = "fill",
    stat = "identity") + RotatedAxis()
```

```{r}
# define colors for the clusters.

cols = rep(NA, 27)
# greens for basal
cols[2:5] = colorRampPalette(c("green", "darkgreen"))(4)
# pink/purple for fibs
cols[7:10] = colorRampPalette(c("pink", "purple3"))(4)
# blu spinous
cols[23:25] = colorRampPalette(c("lightblue", "darkblue"))(3)
# cyans for Granular
cols[11:12] = c("cyan", "cyan3")
# immune cells in yellow to orange
cols[c(1, 6, 15, 16, 18:20, 26)] = colorRampPalette(c("yellow", "red"))(8)
# rest in grays
cols[c(13, 14, 17, 21, 22, 27)] = colorRampPalette(c("grey82", "gray30"))(6)

names(cols) = celltypes

p5 + scale_fill_manual(values = cols)
```

Across all sections, take mean for each method.

```{r}
methods = names(cell.prop)

m.prop =  data.frame(sapply(methods, function(x) rowMeans(tot.prop[,grepl(x, colnames(tot.prop))])))
m.prop$celltype = rownames(m.prop)

l = reshape2::melt(m.prop, id.vars = "celltype")

p5 = ggplot(l, aes(x = variable, y = value, fill = celltype)) + geom_bar(position = "fill",
    stat = "identity") + RotatedAxis()

p5 + scale_fill_manual(values = cols)
```



## Celltypes per spot

What is the abundance of the top celltype per spot. OBS! Would require normalization per spot of the scores.

```{r}

par(mfrow = c(1, 3))
normdata = list()
for (m in methods) {
    d = st.data@assays[[m]]@counts
    d = sweep(d, 2, colSums(d), "/")
    normdata[[m]]=d
    top = apply(d, 2, max)
    hist(top, main = m, n = 100)
}
```

Count number of celltypes per spot, only count ones with proportion > 5% or > 10%




```{r}
par(mfrow = c(1, 3))
for (m in methods) {
    nD = colSums(normdata[[m]] > 0.05)
    hist(nD, main = m, n = 100, ylab = "Celltypes > 5%")
}

par(mfrow = c(1, 3))
num.cells = list()
for (m in methods) {
    nD = colSums(normdata[[m]] > 0.1)
    hist(nD, main = m, n = 100, ylab = "Celltypes > 10%")
    num.cells[[m]]=nD
}
```

Color spots by number of cells with > 10%

```{r, fig.height=10}
st.data$nCell_DWLS = num.cells$DWLS
st.data$nCell_Stereoscope = num.cells$Stereoscope
st.data$nCell_RCTD = num.cells$RCTD

p = SpatialFeaturePlot(st.data, images = samples, features = c("nCell_RCTD", "nCell_Stereoscope", "nCell_DWLS"), combine = F)
grid.arrange(grobs=p, ncol=4)
```

## Celltype co-occurence

Count only celltypes that make up >10% of the spots.

```{r}
cutoff = 0.05

co.occ = lapply(normdata, function(y) sapply(celltypes, function(x) which(y[x,]>cutoff)))

o = overlap_phyper2(co.occ$Stereoscope, co.occ$Stereoscope, title = "Stereocope", remove.diag = T)
o = overlap_phyper2(co.occ$RCTD, co.occ$RCTD, title = "RCTD", remove.diag = T)
o = overlap_phyper2(co.occ$DWLS, co.occ$DWLS, title = "DWLS", remove.diag = T)

```


## Celltypes per cluster

Take the clusters as defined by the integrated clustering and plot celltype proportions

```{r}
cl2spot = split(1:ncol(st.data), st.data$SCT_snn_res.0.5)
unlist(lapply(cl2spot, length))


plot_proportions = function(pred, cell2spot, cols, title="predictions"){
  cl.pred = lapply(cl2spot, function(x) data.frame(value=rowSums(pred[,x])/sum(rowSums(pred[,x])),celltype= rownames(pred)))
  l = reshape2::melt(cl.pred)

  p1 = ggplot(l, aes(x=L1,y=value, fill=celltype)) + geom_bar(position = "fill",stat = "identity") + scale_fill_manual(values = cols) + RotatedAxis() + ggtitle(title)
  print(p1)
}

plot_proportions(st.data@assays$RCTD@counts, cell2spot, cols, title = "RCTD")
plot_proportions(st.data@assays$Stereoscope@counts, cell2spot, cols, title = "Stereoscope")
plot_proportions(st.data@assays$DWLS@counts, cell2spot, cols, title = "DWLS")

```


# Clustering with celltype predictions

Use each of the methods to cluster by celltype proportions

```{r, fig.height=10}
st.data$integrated_clust = st.data$seurat_clusters
nPC = 7

for (meth in methods){
  st.data@active.assay = meth
  umap_name = paste0("umap",meth)
  pca_name = paste0("pca",meth)
  clust_name = paste0(meth,"_clust")
  st.data = ScaleData(st.data)
  st.data = RunPCA(st.data, features = celltypes, reduction.name = pca_name, verbose = F,
    assay = meth)
  st.data = RunUMAP(st.data, reduction = pca_name, reduction.name = umap_name, dims = 1:nPC,
    verbose = F, assay = meth)
  st.data = FindNeighbors(st.data, reduction = pca_name, dims = 1:nPC, verbose = F)
  st.data = FindClusters(st.data, resolution = 0.9, verbose = F)

  p = DimPlot(st.data, reduction = umap_name, group.by = "integrated_clust") + NoAxes()
  p2 = DimPlot(st.data, label = T, reduction = umap_name) + NoAxes() + ggtitle(sprintf("%s clust",meth))
  p3 = DimPlot(st.data, group.by = "Sample_name", reduction = umap_name) + NoAxes()
  grid.arrange(p,p2,p3, ncol = 2)
  
  p3 = SpatialDimPlot(st.data, images = samples, combine = F, group.by = )
  grid.arrange(grobs = p3, ncol=2)
  # add new metadata column
  st.data[[clust_name]] = st.data$seurat_clusters
}


```

Compare all clusterings.

```{r, fig.height=10}
p1 = DimPlot(st.data, group.by = "RCTD_clust", reduction = "umap") + NoAxes()
p2 = DimPlot(st.data, group.by = "Stereoscope_clust", reduction = "umap")+ NoAxes()
p3 = DimPlot(st.data, group.by = "DWLS_clust", reduction = "umap")+ NoAxes()
p4 = DimPlot(st.data, group.by = "integrated_clust", reduction = "umap")+ NoAxes()
grid.arrange(p1,p2,p3,p4, ncol=2)

```


### Session info

```{r}
sessionInfo()
```
